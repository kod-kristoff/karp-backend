{"config":{"lang":["en"],"separator":"[\\s\\-]+","pipeline":["stopWordFilter"]},"docs":[{"location":"development/","title":"Development","text":"<p><code>karp</code> is implemented according to Clean Architecture/Domain-Driven-Design.</p> <p>The repo defines two apps: * <code>karp.webapp</code>: the backend * <code>karp.cliapp</code>: the <code>karp-cli</code> tool to manage the backend</p> <p>The ambition is that the apps only depends on <code>karp.main</code>, <code>karp.lex</code>, <code>karp.search</code> och for the webapp also <code>karp.auth</code> and that <code>karp.main</code> holds the dependency injection stuff that binds implementations from <code>karp.lex_infrastructure</code>, <code>karp.auth_infrastructure</code> and <code>karp.search_infrastructure</code>.</p> <p>This means that <code>karp.auth</code>, <code>karp.lex</code> and <code>karp.search</code> defines the <code>domain</code>, interfaces for needed functionality and the <code>buisness logic</code> of the apps.</p>"},{"location":"development/#references","title":"References","text":"<ul> <li>Clean Architecture</li> <li>Domain-Driven Design</li> </ul>"},{"location":"reference/","title":"Reference","text":"<p>LexicalResource</p>"},{"location":"reference/#karp.lex.domain.entities.resource.Release","title":"<code>Release</code>","text":"<p>         Bases: <code>Entity</code></p>  Source code in <code>karp/lex/domain/entities/resource.py</code> <pre><code>class Release(Entity):\n    def __init__(self, name: str, publication_date: float, description: str, **kwargs):\n        super().__init__(**kwargs)\n        self._name = name\n        self._publication_date = publication_date\n        self._description = description\n\n    @property\n    def name(self) -&gt; str:\n        \"\"\"The name of this release.\"\"\"\n        return self._name\n\n    @property\n    def publication_date(self) -&gt; float:\n        \"\"\"The publication of this release.\"\"\"\n        return self._publication_date\n\n    @property\n    def description(self) -&gt; str:\n        \"\"\"The description of this release.\"\"\"\n        return self._description\n</code></pre>"},{"location":"reference/#karp.lex.domain.entities.resource.Release.description","title":"<code>description: str</code>  <code>property</code>","text":"<p>The description of this release.</p>"},{"location":"reference/#karp.lex.domain.entities.resource.Release.name","title":"<code>name: str</code>  <code>property</code>","text":"<p>The name of this release.</p>"},{"location":"reference/#karp.lex.domain.entities.resource.Release.publication_date","title":"<code>publication_date: float</code>  <code>property</code>","text":"<p>The publication of this release.</p>"},{"location":"reference/#karp.lex.domain.entities.resource.Resource","title":"<code>Resource</code>","text":"<p>         Bases: <code>TimestampedVersionedEntity</code></p>  Source code in <code>karp/lex/domain/entities/resource.py</code> <pre><code>class Resource(TimestampedVersionedEntity):\n    DiscardedEntityError = errors.DiscardedEntityError\n    resource_type: str = \"resource\"\n\n    # @classmethod\n    # def create_resource(cls, resource_type: str, resource_config: Dict):\n    #     if resource_type == cls.resource_type:\n    #         return cls.from_dict(resource_config)\n\n    # @classmethod\n    # def from_dict(cls, config: Dict, **kwargs):\n\n    #     resource_id = config.pop(\"resource_id\")\n    #     resource_name = config.pop(\"resource_name\")\n\n    #     #     entry_repository = EntryRepository.create(\n    #     #         config[\"entry_repository_type\"],\n    #     #         entry_repository_settings\n    #     #     )\n\n    #     resource = cls(\n    #         resource_id=resource_id,\n    #         name=resource_name,\n    #         config=config,\n    #         message=\"Resource added.\",\n    #         op=ResourceOp.ADDED,\n    #         entity_id=unique_id.make_unique_id(),\n    #         version=1,\n    #         **kwargs,\n    #     )\n    #     resource.queue_event(\n    #         events.ResourceCreated(\n    #             entity_id=resource.id,\n    #             id=resource.id,\n    #             resource_id=resource.resource_id,\n    #             name=resource.name,\n    #             config=resource.config,\n    #             timestamp=resource.last_modified,\n    #             user=resource.last_modified_by,\n    #             message=resource.message,\n    #         )\n    #     )\n    #     return resource\n\n    # class NewReleaseAdded:\n    #     def mutate(self, obj):\n    #         obj._validate_event_applicability(self)\n    #         release = Release(\n    #             entity_id=self.release_id,\n    #             name=self.release_name,\n    #             publication_date=self.timestamp,\n    #             description=self.release_description,\n    #             aggregate_root=obj,\n    #         )\n    #         obj._releases.append(release)\n    #         obj._last_modified = self.timestamp\n    #         obj._last_modified_by = self.user\n    #         obj._message = f\"Release '{self.release_name}' created.\"\n    #         obj._increment_version()\n\n    def __init__(\n        self,\n        *,\n        entity_id: unique_id.UniqueId,\n        resource_id: str,\n        name: str,\n        config: Dict[str, Any],\n        message: str,\n        entry_repo_id: unique_id.UniqueId,\n        version: int = 1,\n        op: ResourceOp = ResourceOp.ADDED,\n        is_published: bool = False,\n        # entry_repository_type: typing.Optional[str] = None,\n        # entry_repository_settings: typing.Optional[typing.Dict] = None,\n        # entry_repository: EntryRepository = None,\n        **kwargs,\n    ):\n        super().__init__(entity_id=entity_id, version=version, **kwargs)\n        self._resource_id = resource_id\n        self._name = name\n        self.is_published = is_published\n        self.config = config\n        self._message = message\n        self._op = op\n        self._releases = []\n        # self._entry_repository = None\n        # self.entry_repository_type = entry_repository_type\n        # self.entry_repository_settings = entry_repository_settings\n        self._entry_json_schema = None\n        self._entry_repo_id = entry_repo_id\n        # if not self.events or not isinstance(self.events[-1], events.ResourceCreated):\n        #     self.queue_event(\n        #         events.ResourceLoaded(\n        #             id=self._id,\n        #             resource_id=self._resource_id,\n        #             name=self._name,\n        #             config=self.config,\n        #             timestamp=self._last_modified,\n        #             user=self._last_modified_by,\n        #             message=self._message,\n        #             version=self.version,\n        #         )\n        #     )\n\n    @property\n    def resource_id(self) -&gt; str:\n        return self._resource_id\n\n    @property\n    def entry_repository_id(self) -&gt; unique_id.UniqueId:\n        return self._entry_repo_id\n\n    @property\n    def entry_repository_settings(self) -&gt; typing.Dict:\n        return self.config[\"entry_repository_settings\"]\n\n    @entry_repository_settings.setter\n    def entry_repository_settings(self, entry_repository_settings: typing.Dict):\n        self.config[\"entry_repository_settings\"] = entry_repository_settings\n\n    @property\n    def name(self):\n        return self._name\n\n    @name.setter\n    def name(self, name):\n        self._check_not_discarded()\n        self._name = name\n\n    @property\n    def message(self):\n        return self._message\n\n    @property\n    def releases(self):\n        \"\"\"Releases for this resource.\"\"\"\n        return self._releases\n\n    @property\n    def op(self):\n        return self._op\n\n    # @property\n    # def entry_repository(self):\n    #     from karp.domain.repository import EntryRepository\n\n    #     if self._entry_repository is None:\n    #         self._entry_repository = EntryRepository.create(\n    #             self.entry_repository_type,\n    #             {\"table_name\": self._resource_id, \"config\": self.config},\n    #         )\n    #     return self._entry_repository\n\n    # def stamp(\n    #     self,\n    #     *,\n    #     user: str,\n    #     timestamp: float = None,\n    #     message: str = None,\n    #     increment_version: bool = True,\n    # ):\n    #     self._update_metadata(timestamp, user, message, \"Updated\")\n    #     if increment_version:\n    #         self._version += 1\n    #     self.queue_event(\n    #         events.ResourceUpdated(\n    #             entity_id=self.id,\n    #             resource_id=self.resource_id,\n    #             name=self.name,\n    #             config=self.config,\n    #             version=self.version,\n    #             timestamp=self.last_modified,\n    #             user=self.last_modified_by,\n    #             message=self.message,\n    #             entry_repo_id=self.entry_repository_id,\n    #         )\n    #     )\n\n    def publish(\n        self,\n        *,\n        user: str,\n        message: str,\n        version: int,\n        timestamp: float = None,\n    ):\n        self._update_metadata(timestamp, user, message or \"Published\", version)\n        self.is_published = True\n        self.queue_event(\n            events.ResourcePublished(\n                entity_id=self.id,\n                resource_id=self.resource_id,\n                entry_repo_id=self.entry_repository_id,\n                timestamp=self.last_modified,\n                user=self.last_modified_by,\n                version=self.version,\n                name=self.name,\n                config=self.config,\n                message=self.message,\n            )\n        )\n\n    def set_entry_repo_id(\n        self,\n        *,\n        entry_repo_id: unique_id.UniqueId,\n        user: str,\n        version: int,\n        timestamp: Optional[float] = None,\n    ):\n        self._update_metadata(timestamp, user, \"entry repo id updated\", version=version)\n        self._entry_repo_id = entry_repo_id\n        self.queue_event(\n            events.ResourceUpdated(\n                entity_id=self.entity_id,\n                resource_id=self.resource_id,\n                entry_repo_id=self.entry_repository_id,\n                timestamp=self.last_modified,\n                user=self.last_modified_by,\n                version=self.version,\n                name=self.name,\n                config=self.config,\n                message=self.message,\n            )\n        )\n\n    def set_resource_id(\n        self,\n        *,\n        resource_id: str,\n        user: str,\n        version: int,\n        timestamp: Optional[float] = None,\n        message: Optional[str] = None,\n    ) -&gt; None:\n        self._update_metadata(\n            timestamp, user, message or \"setting resource_id\", version\n        )\n        self._resource_id = resource_id\n        self.queue_event(\n            events.ResourceUpdated(\n                entity_id=self.entity_id,\n                resource_id=self.resource_id,\n                entry_repo_id=self.entry_repository_id,\n                timestamp=self.last_modified,\n                user=self.last_modified_by,\n                version=self.version,\n                name=self.name,\n                config=self.config,\n                message=self.message,\n            )\n        )\n\n    def update(\n        self,\n        *,\n        name: str,\n        config: dict[str, Any],\n        user: str,\n        version: int,\n        timestamp: Optional[float] = None,\n        message: Optional[str] = None,\n    ) -&gt; bool:\n        if self.name == name and self.config == config:\n            return False\n        self._update_metadata(timestamp, user, message or \"updating\", version)\n        self._name = name\n        self.config = config\n        self.queue_event(\n            events.ResourceUpdated(\n                entity_id=self.entity_id,\n                resource_id=self.resource_id,\n                entry_repo_id=self.entry_repository_id,\n                timestamp=self.last_modified,\n                user=self.last_modified_by,\n                version=self.version,\n                name=self.name,\n                config=self.config,\n                message=self.message,\n            )\n        )\n        return True\n\n    def set_config(\n        self,\n        *,\n        config: dict[str, Any],\n        user: str,\n        version: int,\n        timestamp: Optional[float] = None,\n        message: Optional[str] = None,\n    ) -&gt; bool:\n        if self.config == config:\n            return False\n        self._update_metadata(timestamp, user, message or \"setting config\", version)\n        self.config = config\n        self.queue_event(\n            events.ResourceUpdated(\n                entity_id=self.entity_id,\n                resource_id=self.resource_id,\n                entry_repo_id=self.entry_repository_id,\n                timestamp=self.last_modified,\n                user=self.last_modified_by,\n                version=self.version,\n                name=self.name,\n                config=self.config,\n                message=self.message,\n            )\n        )\n        return True\n\n    def _update_metadata(\n        self, timestamp: Optional[float], user: str, message: str, version: int\n    ):\n        self._check_not_discarded()\n        self._validate_version(version)\n        self._last_modified = self._ensure_timestamp(timestamp)\n        self._last_modified_by = user\n        self._message = message\n        self._op = ResourceOp.UPDATED\n        self._increment_version()\n\n    def add_new_release(self, *, name: str, user: str, description: str):\n        self._check_not_discarded()\n        raise NotImplementedError()\n        # event = Resource.NewReleaseAdded(\n        #     entity_id=self.id,\n        #     entity_version=self.version,\n        #     entity_last_modified=self.last_modified,\n        #     release_id=unique_id.make_unique_id(),\n        #     release_name=constraints.length_gt_zero(\"name\", name),\n        #     user=user,\n        #     release_description=description,\n        # )\n        # event.mutate(self)\n\n        # return self.release_with_name(name)\n\n    def release_with_name(self, name: str):\n        self._check_not_discarded()\n        raise NotImplementedError()\n\n    def discard(self, *, user: str, message: str, timestamp: float = None):\n        self._check_not_discarded()\n        self._op = ResourceOp.DELETED\n        self._message = message or \"Entry deleted.\"\n        self._discarded = True\n        self._last_modified_by = user\n        self._last_modified = timestamp or utc_now()\n        self._version += 1\n        self.queue_event(\n            events.ResourceDiscarded(\n                entity_id=self.id,\n                version=self.version,\n                # entry_repo_id=self.entry_repository_id,\n                timestamp=self.last_modified,\n                user=self.last_modified_by,\n                message=self.message,\n                resource_id=self.resource_id,\n                name=self.name,\n                config=self.config,\n            )\n        )\n\n    @property\n    def entry_json_schema(self) -&gt; Dict:\n        if self._entry_json_schema is None:\n            self._entry_json_schema = json_schema.create_entry_json_schema(\n                self.config[\"fields\"]\n            )\n        return self._entry_json_schema\n\n    # @property\n    # def id_getter(self) -&gt; Callable[[Dict], str]:\n    #     return create_field_getter(self.config[\"id\"], str)\n\n    def dict(self) -&gt; Dict:\n        return {\n            \"entity_id\": self.entity_id,\n            \"resource_id\": self.resource_id,\n            \"name\": self.name,\n            \"version\": self.version,\n            \"last_modified\": self.last_modified,\n            \"last_modified_by\": self.last_modified_by,\n            \"op\": self.op,\n            \"message\": self.message,\n            \"entry_repository_id\": self.entry_repository_id,\n            \"is_published\": self.is_published,\n            \"discarded\": self.discarded,\n            \"resource_type\": self.resource_type,\n            \"config\": self.config,\n        }\n\n    def create_entry_from_dict(\n        self,\n        entry_raw: Dict,\n        *,\n        user: str,\n        entity_id: unique_id.UniqueId,\n        message: Optional[str] = None,\n        timestamp: Optional[float] = None,\n    ) -&gt; Entry:\n        self._check_not_discarded()\n        # id_getter = self.id_getter()\n        return create_entry(\n            # id_getter(entry_raw),\n            entry_raw,\n            repo_id=self.entry_repository_id,\n            # resource_id=self.resource_id,\n            last_modified_by=user,\n            message=message,\n            entity_id=entity_id,\n            last_modified=timestamp,\n        )\n\n    def is_protected(self, level: PermissionLevel):\n        \"\"\"\n        Level can be READ, WRITE or ADMIN\n        \"\"\"\n        protection = self.config.get(\"protected\", {})\n        return level == \"WRITE\" or level == \"ADMIN\" or protection.get(\"read\")\n</code></pre>"},{"location":"reference/#karp.lex.domain.entities.resource.Resource.releases","title":"<code>releases</code>  <code>property</code>","text":"<p>Releases for this resource.</p>"},{"location":"reference/#karp.lex.domain.entities.resource.Resource.is_protected","title":"<code>is_protected(level)</code>","text":"<p>Level can be READ, WRITE or ADMIN</p>  Source code in <code>karp/lex/domain/entities/resource.py</code> <pre><code>def is_protected(self, level: PermissionLevel):\n    \"\"\"\n    Level can be READ, WRITE or ADMIN\n    \"\"\"\n    protection = self.config.get(\"protected\", {})\n    return level == \"WRITE\" or level == \"ADMIN\" or protection.get(\"read\")\n</code></pre>"},{"location":"tutorials/","title":"Tutorials","text":"<ul> <li>Add resource</li> <li>Create a resource config</li> <li>Readd a resource</li> </ul>"},{"location":"tutorials/add-resource/","title":"Add a resource to karp","text":"<p>In this tutorial we are gonna add the resource <code>Lex Lex</code> to Karp.</p> <p>All commands are supposed to run after <code>poetry shell</code> (that is, in an activated virtual environment).</p> <ol> <li>Create a resource config</li> <li>In this example we have saved the config in <code>path/to/parolelexplus.json</code></li> <li>Add an entry repository: <code>karp-cli entry-repo create path/to/parolelexplus.json</code></li> <li>Add a resource: <code>karp-cli resource create path/to/parolelexplus.json</code></li> <li>This command will list currently non-deleted entry-repos along with numbers, choose the highest number for your resource</li> <li>In our running example, choose: <code>parolelexplus</code></li> <li>Publish the resource: <code>karp-cli resource publish &lt;resource_id&gt;</code></li> <li>In our example: <code>karp-cli resource publish parolelexplus</code></li> <li>Before adding entries, we can dry-run and validate them: <code>karp-cli entries validate --resource_id &lt;resource_id&gt; &lt;path/to/entries&gt;</code></li> <li>In our example: <code>karp-cli entries validate --resource_id parolelexplus path/to/parolelexplus.jsonl</code></li> <li>Adding entries, can be done in 2 ways, both methods can read <code>json</code>, <code>jsonl</code>, <code>json.gz</code> or <code>jsonl.gz</code> files:</li> <li>Add all in one go: <code>karp-cli entries add &lt;resource_id&gt; &lt;path/to/entries&gt;</code><ul> <li>In our example: <code>karp-cli entries add parolelexplus path/to/parolelexplus.jsonl</code></li> </ul> </li> <li>Add all but in chunks: <code>karp-cli entries add &lt;resource_id&gt; &lt;path/to/entries&gt; --chunked --chunk-size &lt;number (default: 1000)&gt;</code><ul> <li>This version works by addind <code>&lt;chunk-size&gt;</code> entries to the database and indexes them in the search-service (e.g. ElasticSearch).</li> <li>The pro with this method is that not all entries are held in memory.</li> <li>The con is that if a later chunk fails, all previously added chunks are stored, that is the resource is partially added. Manual intervention can be needed.</li> <li>In our example: <code>karp-cli entries add parolelexplus path/to/parolelexplus.jsonl --chunked --chunk-size 10000</code></li> </ul> </li> <li>NOTE If are going to add a large resource this can take several hours, please use <code>nohup</code> for better experience.<ul> <li>For instance <code>nohup karp-cli entries add &lt;resource_id&gt; &lt;path/to/entries&gt; --chunked &gt; stdout.log 2&gt; stderr.log.jsonl &amp;</code>.</li> <li>Karp print logs to stderr in jsonl format.</li> <li>In our example: <code>nohup karp-cli entries add parolelexplus path/to/parolelexplus.jsonl --chunked &gt; stdout.log 2&gt; stderr.log.jsonl &amp;</code></li> </ul> </li> </ol>"},{"location":"tutorials/create-resource-config/","title":"Create a Resource Config","text":"<p>In this tutorial we are going to create a resource config for the resource <code>parolelexplus</code>.</p> <p>Some entries in this resource looks like this:</p> <pre><code>{\"wordform\": \"skyddsf\\u00f6reskrift\", \"partOfSpeech\": \"nn\", \"valency\": \"(ATTR) [nn] (ATTR)\", \"paroleID\": \"US14440_15998\"}\n{\"wordform\": \"arrangerar\", \"saldo\": [\"arrangera..1\"], \"partOfSpeech\": \"vb\", \"valency\": \"S_NP_A [vb] DO_NP_x (PO_PP_f\\u00f6r_y)\", \"paroleID\": \"US675_727\"}\n{\"wordform\": \"konstruktion\", \"saldo\": [\"konstruktion..1\"], \"partOfSpeech\": \"nn\", \"valency\": \"[nn] (PP_av_NP_x)\", \"paroleID\": \"US8133_8951\"}\n{\"wordform\": \"kort\", \"saldo\": [\"kort..1\"], \"partOfSpeech\": \"av\", \"valency\": \"SUPR_[av]\", \"paroleID\": \"US8254_9087\"}\n{\"wordform\": \"avmagrad\", \"saldo\": [\"avmagrad..1\"], \"partOfSpeech\": \"av\", \"valency\": \"[av] NP\", \"paroleID\": \"US909_978\"}\n{\"wordform\": \"samlar\", \"saldo\": [\"samla..1\", \"samla..2\"], \"partOfSpeech\": \"vb\", \"valency\": \"S_NP_A [vb] DO_NP_x\", \"paroleID\": \"US13500_14968\"}\n{\"wordform\": \"myser\", \"saldo\": [\"mysa..1\"], \"partOfSpeech\": \"vb\", \"valency\": \"S_NP_A [vb] (PO_PP_mot_B)\", \"paroleID\": \"US10239_11340\"}\n{\"wordform\": \"s\\u00e4krar\", \"saldo\": [\"s\\u00e4kra..1\"], \"partOfSpeech\": \"vb\", \"valency\": \"S_NP_A/x [vb] DO_NP_y\", \"paroleID\": \"US16362_18148\"}\n{\"wordform\": \"f\\u00f6renlig\", \"saldo\": [\"f\\u00f6renlig..1\"], \"partOfSpeech\": \"av\", \"valency\": \"[av] PP_med_NP_x\", \"paroleID\": \"US4828_5353\"}\n{\"wordform\": \"hastighet\", \"saldo\": [\"hastighet..1\"], \"partOfSpeech\": \"nn\", \"valency\": \"(ATTR) [nn] (ATTR)\", \"paroleID\": \"US6093_6719\"}\n</code></pre>"},{"location":"tutorials/create-resource-config/#resource_id-required","title":"<code>resource_id</code> [required]","text":"<p>We need to define the <code>resource_id</code> for our resource, this will be used when we call the api. The <code>resource_id</code> can't contain whitespace and should preferrable only contain lowercase letters.</p> <pre><code>{\n  \"resource_id\": \"parolelexplus\"\n}\n</code></pre>"},{"location":"tutorials/create-resource-config/#resource_name-optional","title":"<code>resource_name</code> [optional]","text":"<p>We could also define the <code>resource_name</code> for our resource, if not the <code>resource_id</code> will be used.</p> <pre><code>{\n  \"resource_id\": \"parolelexplus\",\n  \"resource_name\": \"parolelexplus\"\n}\n</code></pre>"},{"location":"tutorials/create-resource-config/#fields-required","title":"<code>fields</code> [required]","text":"<p>Here we define the fields that the entries in the resource will have. The fields are defined by <code>\"&lt;field_name&gt;\": {\"type\": \"&lt;field_type&gt;\"}</code> where field_type can be any of:</p>    field_type python_type comment     <code>string</code> <code>str</code> smaller kind of string   <code>long_string</code> <code>str</code> larger kind of string, exact limit?   <code>boolean</code> <code>bool</code>    <code>integer</code> <code>int</code>    <code>number</code> <code>float</code>    <code>object</code> <code>dict</code> requires the field <code>fields</code> that define fields    <p>So we begin with adding config for the <code>paroleID</code> field of type <code>string</code>:</p> <pre><code>{\n  \"resource_id\": \"parolelexplus\",\n  \"resource_name\": \"parolelexplus\",\n  \"fields\": {\n    \"paroleID\": { \"type\": \"string\", \"required\": true }\n  }\n}\n</code></pre> <p>After we can handle all <code>string</code> fields:</p> <pre><code>{\n  \"resource_id\": \"parolelexplus\",\n  \"resource_name\": \"parolelexplus\",\n  \"fields\": {\n    \"paroleID\": { \"type\": \"string\", \"required\": true },\n    \"wordform\": { \"type\": \"string\", \"required\": true },\n    \"partOfSpeech\": { \"type\": \"string\" },\n    \"valency\": { \"type\": \"string\" }\n  }\n}\n</code></pre> <p>Currently <code>array</code>:s are specified by defining the type and and then adding the field <code>collection</code> as in:</p> <pre><code>{\n  \"resource_id\": \"parolelexplus\",\n  \"resource_name\": \"parolelexplus\",\n  \"fields\": {\n    \"paroleID\": { \"type\": \"string\", \"required\": true },\n    \"wordform\": { \"type\": \"string\", \"required\": true },\n    \"partOfSpeech\": { \"type\": \"string\" },\n    \"valency\": { \"type\": \"string\" },\n    \"saldo\": { \"type\": \"string\", \"collection\": true }\n  }\n}\n</code></pre>"},{"location":"tutorials/create-resource-config/#id-required","title":"<code>id</code> [required]","text":"<p>Currently not used, but requried to set.</p> <pre><code>{\n  \"resource_id\": \"parolelexplus\",\n  \"resource_name\": \"parolelexplus\",\n  \"fields\": {\n    \"paroleID\": { \"type\": \"string\", \"required\": true },\n    \"wordform\": { \"type\": \"string\", \"required\": true },\n    \"partOfSpeech\": { \"type\": \"string\" },\n    \"valency\": { \"type\": \"string\" },\n    \"saldo\": { \"type\": \"string\", \"collection\": true }\n  },\n  \"id\": \"paroleID\"\n}\n</code></pre>"},{"location":"tutorials/create-resource-config/#sort-required","title":"<code>sort</code> [required]","text":"<p>Specifies by which field the entry shall be sorted by.</p> <pre><code>{\n  \"resource_id\": \"parolelexplus\",\n  \"resource_name\": \"parolelexplus\",\n  \"fields\": {\n    \"paroleID\": { \"type\": \"string\", \"required\": true },\n    \"wordform\": { \"type\": \"string\", \"required\": true },\n    \"partOfSpeech\": { \"type\": \"string\" },\n    \"valency\": { \"type\": \"string\" },\n    \"saldo\": { \"type\": \"string\", \"collection\": true }\n  },\n  \"id\": \"paroleID\",\n  \"sort\": \"wordform\"\n}\n</code></pre>"},{"location":"tutorials/readd-resource/","title":"Add a resource to karp","text":"<p>In this tutorial we are gonna add the resource <code>Lex Lex</code> to Karp.</p> <p>All commands are supposed to run after <code>poetry shell</code> (that in an activated virtual environment).</p> <ol> <li>Create a resource config</li> <li>Add an entry repository: <code>karp-cli entry-repo create &lt;path&gt;</code></li> <li>Add a resource: <code>karp-cli resource create &lt;path&gt;</code>     Same path as above, use the latest number in list.</li> <li>Add entries </li> </ol>"}]}